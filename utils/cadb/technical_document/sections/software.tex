\section{软件部分}
    \subsection{设计原理}
        软件端设计与硬件端匹配，与硬件端约定接收、发送规则，%
        接收、发送消息的格式，%
        同时为了解决数据传输过程中可能出现的错误，%
        还需要处理系统缓冲区、检测丢包现象，%
        从而保证调试工具正常运行。%
    \subsection{整体设计}
        软件端开始运行后读取配置文件，尝试连接串口，%
        以上操作均成功后，进入用户操作界面。
            
        \subsubsection{通信命令编码}
            对于每个用户输入的命令，软件端将命令编码后发送给硬件端，%
            根据命令类型决定是否阻塞并等待硬件端数据。

            通信编码共17字节，命令编码规则如下表所示。%
            图中编码低序字节最先发送，高序字节最后发送。

            \begin{tabularx}{\textwidth}{llX}
                \toprule
                命令 & 通信编码 & 说明 \\
                \midrule
                run        & 0x<128位全0>01 & 运行此命令后软件端阻塞，等待硬件端数据。 \\
                \midrule
                break      & 0x<64位掩码><64位数据>02 & 64位数据为断点条件，%
                                                        掩码为1表示数据有效，%
                                                        掩码为0表示数据通配，%
                                                        数据和掩码均采用小端法。 \\
                \midrule
                continue   & 0x<128位全0>03 & 运行此命令后软件端阻塞，等待硬件端数据。 \\
                \midrule
                step       & 0x<64位全0><64位数据>04 & 64位数据为前进时钟数，%
                                                       运行此命令后软件端阻塞，%
                                                       等待硬件端数据。 \\
                \midrule
                print      & & 此命令无需与硬件端通信。 \\
                \midrule
                display    & & 此命令无需与硬件端通信。 \\
                \midrule
                undisplay  & & 此命令无需与硬件端通信。 \\
                \midrule
                help       & & 此命令无需与硬件端通信。 \\
                \midrule
                quit       & & 此命令无需与硬件端通信。 \\ 
                \bottomrule
            \end{tabularx}

        \subsubsection{通信数据编码}
            软件运行后会自动读取当前目录下cadb.cfg文件。%
            配置文件需要用户自行编写，共三列，%
            第一列是软件端查看变量值时的标签，接受不包含空白字符的字符串。
            第二列是VHDL源代码中实际被查看信号名称，%
            接收不包含空白字符的字符串，在被调试模块中应有同名信号，%
            且该信号不能为输出端口。
            第三列是被查看信号的范围。%
            对于std\_logic\_vector应标明范围，%
            对于std\_logic第三列置空。

            生成VHDL代码时，程序会根据信号长度在通信数据格式中从低到高分配，%
            对于长度不是8的整数倍的信号，会填充0以实现8对齐。%
            每次收到硬件端发送的数据后，软件端会根据该格式解析出对应的信号值。%
            因此每次修改配置文件后都应该重新生成VHDL代码并应用到硬件中。%
            数据在传输和保存过程中采用小端法，%
            因此在打印变量时从高序字节开始打印。

            若要修改通信数据总长度，%
            应在软件端源代码中修改类Parser的静态成员常量MSG\_LENGTH的值，%
            同时在硬件端做相应修改。%
            注意该值在软件端以字节为单位，在硬件端以位为单位。

        \subsubsection{系统缓冲区管理}
            Unix操作系统中为串口设置有缓冲区，%
            缓冲区大小因操作系统不同而有所差异。%

            为了避免软件运行过程中受缓冲区原有数据影响而造成通信不同步，%
            软件启动时和run命令发送之前应清空系统缓冲区。%
            清空方法为：不断尝试读取串口，直到连续10ms读取不到数据为止。

        \subsubsection{丢包检测}
            在软硬件两端通信协议设置正确且%
            硬件运行过程中能够到达断点条件的前提下，软件端一直阻塞，%
            则说明发生了串口传输丢包现象。%
            此时应重启软件端。

            本工具自开发使用以来从未发现丢包现象。
        \subsubsection{串口通信参数}
            软件端串口通信管理在源代码类Communicator中，%
            如果需要修改波特率等串口通信参数，请在硬件端和软件端同时修改。
        
