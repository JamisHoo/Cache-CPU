MMU模块接口说明
    in: clk                     std_logic
        说明：CPU时钟信号

    in: mmu_clock               std_logic
        说明：访存相关时钟信号
            内存的时钟频率和CPU工作的时钟频率并不相同，内存的时钟频率比CPU块
        
    in: state                   std_logic_vector(3 downto 0)
        说明：CPU状态机信号
        
    in: mem_read_enable         std_logic
        说明：内存读使能
        来源：MEM模块
        到达时间：访存阶段时钟上升沿之前
        
    in: mem_write_enable        std_logic
        说明：内存写使能
        来源：MEM模块
        到达时间：访存阶段时钟上升沿之前
        
    in: if_addr                 std_logic_vector(31 downto 0)
        说明：取指令地址
        来源：IFetch模块
        到达时间：取指令时钟上升沿之前
        
    in: mem_addr                std_logic_vector(31 downto 0)
        说明：访存阶段（不包括取指令）的访存地址
        来源：MEM模块
        到达时间：访存阶段时钟上升沿之前
        
    in: mem_write_value         std_logic_vector(31 downto 0)
        说明：内存写入值
        来源：MEM模块
        到达时间：访存阶段时钟上升沿之前
        
    in: cp0_value               std_logic_vector(159 downto 0)
        说明：来自CP0的数据，支持TLBWI指令
        来源：CP0模块
        到达时间：TLBWI指令执行阶段时钟上升沿之前
        
    in: tlbwi_enable            std_logic
        说明：TLB写使能
        来源：IDecode模块
        到达时间：当前指令解码时钟上升沿之后
        
    out: mem_value              std_logic_vector(31 downto 0)
        说明：读取内存的结果
        产生时间：访存阶段时钟下降沿之后
    
    
MMU模块内部实现
    MMU模块作为真实访问物理内存阶段的预处理阶段，
    完成对内存的读写控制
    完成TLB查询，充填TLB，抛出TLB异常等操作
    并且检查地址是否对齐，根据指令类型抛出地址不对齐异常。
    
    
    MMU模块需要利用时钟的两个跳变沿
    访存阶段上升沿：
        虚拟地址到物理地址的转换，检查地址是否对齐，是否抛出TLB、不对齐等异常
    访存阶段下降沿：
        实际对物理内存的访问
    
    MMU模块读写控制，需要通过CPU状态机信号以及内存的读写使能信号共同决定。
        如果当前state为取指令阶段，则一定为内存读取状态
        如果当前为第一访存阶段
            因为SB指令读写使能均为1，所以需要进行
            如果mem_read_enable为1则进行读操作，否则如果mem_write_enable为1则进行写操作
        如果当前为第二访存阶段
            则一定为SB指令，进行写操作
    
    MMU地址映射，根据访问的地址值进行判断。
    只对部分地址（[0x20000000,0x80000000]和[0xC0000000,0xFFFFFFFF]）进行映射，
    其他地址不经转换，直接访问
    
    TLB表查找
        TLB表采取并行查找的策略，实际实现中直接采用for_generate/if_generate语句生成TLB查找表
        实际效果相当于将输入的虚拟地址高19位复制16份，同时与16个EntryHi进行比较，
        结果为16位std_logic_vector，其中只有1位为1，其余15位为0
        
        再利用for_generate/if_generate语句生成TLB结果暂存表，为32*21矩阵
        32行对应一个16个TLB表项全部Lo部分，21为20位物理地址加一位D标志位
        
        利用并行比较结果和虚拟地址最低位，共同对暂存表进行与操作，
        由于其中包含大量的0，最终只选择出1*21的std_logic_vector向量，即为20位物理地址与一位D标记位
        
        如果查找到TLB查找到物理地址，且D标记位有效，则TLB查找成功，否则查找失败
    
    TLB表重填
        TLB数据来源来自于CP0寄存器，共需要Index、PageMask、EntryHi、EntryLo0、EntryLo1五个寄存器的数值
        CP0模块与MMU模块之间始终有以上5个寄存器的连线，始终能够获得CP0寄存器的最新值
        TLB充填发生在TLBWI指令的执行阶段，在时钟上升沿、state为执行阶段、tlb_enable使能信号为1的情况下，重填TLB表项
    
    
    MMU模块可能出现5种异常，异常信号均在访存阶段时钟上升沿之后、时钟下降沿之前产生。
    异常信号输出至异常处理模块，并且对时钟下降沿的访存操作进行控制，如果出现异常则下降沿不进行访存。
    地址不对齐异常两种：
        根据指令类型判断当前指令是否需要对齐地址进行访问
        （LB/SB/LBU指令不需要对齐地址，LHU指令对齐方式待定）
        根据访存地址后两位判断地址是否对齐
        根据读写使能最终确定两种异常中的某一种
    TLB异常共三种：
        均在TLB查找结束之后生成。
        TLB缺失异常信号，根据查找的结果进行判断，如果为全零则根据度写使能触发异常
        TLB修改异常，TLB查找结果的D标志位进行判断
        