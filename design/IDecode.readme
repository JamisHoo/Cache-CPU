IDecode模块接口说明
clk : in std_logic;
state : in status;
instruction : in std_logic_vector(31 downto 0);
	说明：当前指令
    来源：MMU模块
    到达时间：当前指令InsD上升沿之前
    产生时间：当前指令InsF上升沿之后
    
instr_out : out std_logic_vector(31 downto 0);
	说明：指令寄存器，除三个寄存器的编号，其他所有控制线均从此产生。
            之后周期中如果需要用到指令也从此处获得
    产生时间：当前指令InsD上升沿之后
    
rs_addr : out std_logic_vector(4 downto 0);
    说明：通用寄存器编号1，在InsD阶段需要读取到值
    产生时间：当前指令InsD上升沿之前
    
rt_addr : out std_logic_vector(4 downto 0);
    说明：通用寄存器编号2、写入寄存器编号，在InsD阶段需要读取到值
    产生时间：当前指令InsD上升沿之前
    
rd_addr : out std_logic_vector(4 downto 0);
	说明：CP0寄存器编号、写入寄存器编号，在InsD阶段需要读取到值
    产生时间：当前指令InsD上升沿之前

以下信号产生时间均为当前指令InsD上升沿之后
有效时间到下一条指令InsD上升沿之后

pc_op : out std_logic_vector(1 downto 0);
    说明：PCSrc选择器，正常状态下PC的选择方式
            输出到WB模块，4选1数据选择器的控制信号，选择正确的PC
            
eret_enable : out std_logic;
    说明：ERET使能，对PC进行选择
            专门对ERET指令使用，输出到IFetch模块
    
comp_op : out std_logic_vector(2 downto 0);
	说明：比较信号，branch指令的跳转条件
            输出到WB模块，如果为branch系列指令则通过此信号进行选择
    
imme : out std_logic_vector(31 downto 0);
    说明：32位立即数，针对不同指令的需求产生
            立即数本身作为ALUSrc的来源之一
    
alu_ops : out std_logic_vector(8 downto 0);
	说明：控制ALU模块
        ALUSrcA(8 downto 7)：ALU第一输入的选择信号
                             四选一数据选择
        ALUSrcB(6 downto 5)：ALU第二输入的选择信号
                             四选一数据选择
        ALUOp(4 downto 0)：ALU操作
                             暂定4位，可以扩展为5位，详细说明见表格
    
mem_op : out std_logic_vector(2 downto 0);
    说明：控制MEM模块
        MEMRead(2)：是否可读内存
        MEMWrite(1)：是否可写内存
        MEMValue(0)：选择写入内存的值
                        寄存器的数据或者SB指令处理之后的数据
        
wb_op : out std_logic_vector(5 downto 0);
    说明：控制WB模块
        RegDst(5 downto 4)：写回寄存器编号
                            rt或者rd或者31号寄存器
        RegValue(3 downto 1)：写回寄存器的内容
                                信号详细说明见表格
        RegWrite(0)：寄存器是否可写
    
cp0_op : out std_logic_vector(1 downto 0);
	说明：控制CP0模块
        EPCValue(1)：异常产生时，EPC写入的内容
                        选择写入PC或者PC+4
        CP0Write(0)：CP0寄存器是否可写
        
tlbwi_enable : out std_logic;
    说明：TLB写使能
    




    
IDecode内部实现

需要的数据有instruction
产生于当前指令InsF上升沿之后，能够在当前指令InsD上升沿之前到达

内部实现分为两部分：
1、在InsD阶段除了解码指令之外，还需要读取通用寄存器和CP0寄存器的值。
    需要在InsD上升沿到来之前，将三个寄存器编号发送给寄存器堆
    因此将instruction的三个5位的寄存器编号直接连接到输出的rs、rt、rd部分

2、其他控制线的生成均通过时钟驱动，在IDEcode有相应寄存器，连接至输出端
    在InsD时钟上升沿之后，根据指令解码产生控制信号。
    产生的控制信号根据需要，输出到ALU、WB、MEM、CP0、IFetch、MMU模块。
    