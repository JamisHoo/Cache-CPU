\section{模块设计}
    \subsection{取指令模块}
        \subsubsection{端口说明}
            \input{chart/if_module_port.tex} 
        \subsubsection{内部实现}
            需要的数据有PcSrc、EBase、EPC。

            PcSrc产生于上一条指令的WB阶段。%
            EBase为固定值，直接从CP0部分连接过来。%
            EPC在异常阶段写入，直接从CP0部分连接过来。%
            pc\_sel为上一条指令的解码阶段产生。%
            因此，所有的数据都能够在InsF时钟上升沿之前准备完毕。

            内部分为两个部分对PC进行计算：%
            首先为组合逻辑部分，需要在InsF时钟上升沿到来之前为MMU计算出PC值，%
            因此建立一个process，敏感信号为全部的PC选择信息，%
            即时计算出PC值，连接到MMU部分，%
            使得MMU能够在InsF上升沿进行取指令的操作。%
            其次为时序逻辑部分，在InsF时钟上升沿时，%
            对PC进行选择，选择方式与PCmmu相同。%
            此process产生的PC，在当前指令的全部周期有效，%
            是计算RPC、branch、jump的地址的基础。%
    \subsection{指令解析模块}
        \subsubsection{端口说明}
            \input{chart/id_module_port.tex}
        \subsubsection{内部实现}
            需要的数据有instruction，%
            产生于当前指令InsF上升沿之后，能够在当前指令InsD上升沿之前到达。

            内部实现分为两部分：%
            \begin{enumerate}
            \item
            在InsD阶段除了解码指令之外，%
            还需要读取通用寄存器和CP0寄存器的值。%
            需要在InsD上升沿到来之前，将三个寄存器编号发送给寄存器堆。%
            因此将instruction的三个5位的寄存器编号直接连接到输出的rs、rt、rd部分。%
            \item
            其他控制线的生成均通过时钟驱动，%
            在IDEcode有相应寄存器，连接至输出端。%
            在InsD时钟上升沿之后，根据指令解码产生控制信号。%
            产生的控制信号根据需要，%
            输出到ALU、WB、MEM、CP0、IFetch、MMU模块。
            \end{enumerate}

    \subsection{ALU模块}
        \subsubsection{端口说明}
            \input{chart/alu_module_port.tex}
        \subsubsection{内部实现}
            每次时钟上升沿到来时，检查enable、state，%
            若不是ALU工作状态则不进行任何操作。%
            根据alu\_srcA选择第一个操作数，根据alu\_srcB选择第二个操作数，%
            根据操作码进行相应的运算，将结果输出或保存到hi、lo寄存器中。

            注意乘法运算需要较多的时间，因此若在某一个时钟上升沿进行乘法运算，%
            不能认为在下一个时钟上升沿就能在hi、lo寄存器中取到正确的结果。%
            一般来说，在12.5MHz时钟频率下进行乘法运算需要大约2个时钟周期，%
            那么如果在多周期CPU上，%
            可以保证两条连续的乘法、取hi(lo)寄存器指令能得到正确的结果，%
            但是在流水线CPU上不能保证。%
            乘法运算时间需要根据不同的硬件平台、时钟频率进行测量，%
            不能一概而论。
