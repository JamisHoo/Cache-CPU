\section{操作系统与编译}
    此次实验中操作系统也是一个重要的组成部分，%
    需要根据硬件的实现情况对操作系统做出相应的修改。%

        \subsection{操作系统组成}
            此次实验中操作系统%
            bootloader部分使用贾开学长的代码%
            （与Flash访问方式有关），%
            其余均在刘亚宁学长os\_lab基础上进行修改，%
            具体修改内容之后有详细叙述。

        \subsection{时钟中断}
            在os\_lab中，启动过程中是通过MASK位进行中断屏蔽，%
            保证不会被时钟中断所打断。

            此次试验在硬件上没有提供对MASK位的支持，选择在操作系统上进行修改。%
            CP0的Compare寄存器初始化为0xFFFFFFFF，保证初始化结束之前一定不会触发时钟中断。%
            初始化完成后增加一次对clock\_intr函数的调用，%
            将Compare寄存器重填为设定的数字，之后即可触发时钟中断。

            标准MIPS时钟中断的“读Count写入Compare”功能，%
            已经在os\_lab中通过软件方式解决，不需要另作处理。

        \subsection{串口地址}
            从lab3开始，代码支持了在实验板与qemu两个平台上的运行，%
            两平台的串口地址不同。因此，在编译操作系统前需要先调用to\_thin脚本，%
            将操作系统转换为实验板上的版本。

        \subsection{异常处理向量}
            异常处理向量只有唯一的一个入口0x80000180，%
            在初始化阶段直接写入EBASE寄存器之后就不需要再进行修改了。%
            异常处理的初始化完全由操作系统完成，%
            在0x80000180存入一条jump指令，%
            跳转值alltraps函数，硬件上不需要任何的特殊处理。%

        \subsection{Flash访问}
            因为Flash数据线只有16条，%
            所以实际上Flash连续的4个byte中只有2个为有效数据，%
            因此产生了两种Flash访问方式如下：

            一种方式为每次访问Flash的4个byte，%
            得到32位数据中只有低16位有效。%
            之后在软件层进行控制，连续访问两次，%
            将结果移位拼接得到32位有效数据。%
            另一种方式为每次访问Flash在硬件上访问8个byte，%
            硬件上将两次得到的数据进行拼接，%
            对操作系统层提供与RAM访问相同的接口。

            此次实验中使用第一种方式。%
            因此在bootloader中使用贾开学长的代码，%
            其中包含了将访存结果移位拼接的实现。%
            除bootloader之外的操作系统使用刘亚宁学长的代码，%
            这些代码需要第二种Flash访问方式进行支持。

            lab1到lab7不需要进行任何修改，%
            因为所有Flash访问操作均是在bootloader部分完成。%
            在lab8中由于涉及到文件系统sfs.img的加载，%
            需要修改lab8/kern/fs/devs/dev\_disk0.c%
            中的disk0\_read\_blks\_nolock函数，%
            将Flash起始地址与DISK0\_BLKSIZE均乘2，%
            之后通特别外实现的memcpy\_flash将sfs.img加载到内存中。

        \subsection{编译工具}
            此次实验中采用的编译工具为%
            mips-linux-gnu工具链，%
            版本为(Sourcery CodeBench Lite 2014.05-27)%
            2.24.51.20140217。%
            编译器版本不同可能导致代码段组装顺序不同，进而可能产生问题。%
    
            可能需要修改kern\_boot函数，设置栈指针为代码段顶端的kern\_init函数。
