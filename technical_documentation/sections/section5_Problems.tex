\section{问题与解决}
    在CPU的测试阶段中，
    我们发现了很多在编码阶段比较难预想到的问题。
    我们将这些问题记录在这里，
    记录我们的调试过程，
    同时也希望能对未来完成此实验的同学有所帮助。

    \subsection{编译工具}
        此次实验中采用的编译工具为
        mips-linux-gnu工具链，
        版本为(Sourcery CodeBench Lite 2014.05-27)
        2.24.51.20140217。
        编译器版本不同可能导致代码段组装顺序不同，进而可能产生问题。

        问题现象：在实验中运行lab1时，
        在bootloader运行结束后，运行kern\_boot函数，
        设置栈指针sp的初始值为kern\_boot。
        但是kern\_boot函数位于代码段的中央，
        由此导致数据段将代码段覆盖。
        原因为刘亚宁学长使用的编译器将kern\_boot布局在代码段的顶端，
        而我们的编译器将kern\_boot布局于中间部分。

        解决方案：修改了kern\_boot函数，设置栈指针为代码段顶端的kern\_init函数。

    \subsection{PC选择信号}
        实验中PC共有三种可能来源，
        正常运行下PC的计算结果，
        触发异常后的EBASE，异常返回时的EPC。
        控制将EPC赋值给PC的信号eret\_enable由指令解码模块产生。
        原实现方案中，该信号在eret指令解码阶段产生，
        保持到下一条指令的解码阶段。
        但是在lab5运行时出现错误，不能正常运行。

        后发现，lab5中syscall触发异常，
        在处理过程中将EPC改为用户态程序的入口，
        eret指令后PC即为用户态程序的入口。
        但是下一条指令取指阶段会发生TLBmiss，
        立即进入异常处理，并没有进入解码阶段，
        导致eret\_enable信号并没有被消掉，
        后续指令无法正常执行。

        解决方案：修改解码模块，
        将eret\_enable信号在指令的取指阶段消除。

    \subsection{MMU访存地址}
        原实现方案中，在访存和取指阶段的上升沿，
        MMU模块对访存的地址进行锁存。
        后续的TLB查找，物理地址的生成均以此地址为基础。

        但在实际访存过程中，由于整合了多种访存方式，
        需要进行更多的判断，因此访存会持续多个时钟上升沿。
        在取指阶段由于并没有进行PCmmu的锁存，因此可能发生变化，
        相当于进行了两次地址的锁存。
        虽然可以控制真实的访存过程只发生第一次，
        但是对异常地址的判断可能进行多次，导致指令运行出现错误。

        解决方案：在访存和取指阶段的上升沿，
        而且还没开始进行真正的访存时
        （一定是第一个上升沿）才对地址进行锁存。

    \subsection{TLB查找策略}
        TLB表项含有两个EntryLo，
        根据虚拟地址的第20位选择命中其中一个地址。
        原实现方案参照贾开学长的代码，
        但实际运行中发现EntryLo命中错误，本应命中与Lo0的页命中在了Lo1。

        原因可能为TLBWI时的写入策略不同，
        两个EntryLo寄存器写入TLB的位置不同。

        解决方案：在向勇老师的课件中发现了TLB的详细实现方案，
        按照该方案进行了调整，TLB运行正常。
        之后的实现可以参照该课件进行实现。

        此外，原实现方案为保证效率，
        TLB采用了全相连映射的并行查找策略，
        利用VHDL的generate语句生成。
        但是由于VHDL不支持Verilog中的一些语法特性，
        导致代码的实现比较繁复冗余。
        后发现使用串行判断并不会过多地影响CPU速度，
        因此之后的实现可以直接采用串行判断的方法，代码比较简洁。

    \subsection{寄存器写入}
        CP0寄存器需要在ID阶段的上升沿根据访存得到的指令，
        确定读取寄存器的位置，和写入寄存器的位置。

        原实现方案中，在CP0模块中没有对两个位置进行锁存。
        由于访存模块返回的数据可能在一条指令的不同阶段发生变化，
        由此导致CP0寄存器通过mtc0写入的过程中出现错误。

        解决方案:在CP0模块中增加锁存器，
        在ID阶段的上升沿就锁存读写两个位置，
        保证写入过程的正确。

        在通用寄存器中仍然存在类似问题，
        解决方案为将ID模块生成的寄存器写回的使能信号发送给WB模块，
        通过WB模块控制写入信号只保持一个阶段。

    \subsection{访存计数}
        需要将多种访存整合成为统一的接口，
        需要利用一些时钟上升沿进行访存类型等信息的判断。
        因此需要更长的访存时间，有可能超出一个时钟上升沿。

        原实现方案为在访存模块加一个busy为表示正在进行访存，
        此时CPU主状态机保持原来的值。
        但是在某些情况下可能出现连续多次访存的情况。

        解决方案：引入一个counter信号，
        当状态机发生变化时清零，表示新的访存阶段开始。
        状态机不变时保持为1，表示还是原来的访存。
        只有当counter为1的时候读写使能信号均置为0，
        表示可以进行访存。由此保证真实的访存操作只进行一次。

    \subsection{其他}
        实现过程中参考了刘亚宁学长暑期的实验进展报告，
        比较方便地避免了其中提到的很多问题。

        其中比较重要的是J/JAL指令的实现，
        实验指导文档上的说明有误。
        以及在ucore未实现命令的避免部分的TICK_NUM问题。
