\section{软件硬件接口}
    在实际的开发过程与ucore的调试过程中，
    我们逐渐发现了一些在设计过程中没有注意到的软件硬件接口问题。
    为记录我们开发的过程，
    同时也为了后续完成此实验的同学能够有所参考，
    我们特别加入软件硬件接口这部分内容。

    \subsection{异常中断相关}
        \subsubsection{寄存器与中断异常编号}
            CP0寄存器编号和异常编号与标准MIPS相同，
            具体可以参考《See MIPS Run》，
            原实验指导文档中的寄存器编号有误。

            异常编号与标准MIPS相同，
            具体可以参考《See MIPS Run》，
            指导文档该部分也是正确的，可以参考。

            中断在此次实验中实现了时钟中断与串口中断，
            其编号没有统一标准，各种实现版本均不同。
            此次实验以刘亚宁学长的os\_lab为主要参考，
            因此串口中断标号为2，时钟中断编号为7

        \subsubsection{时钟中断}
            标准MIPS中可以通过status寄存器中的EXL与EL位进行整体的中断屏蔽，
            还可以通过MASK进行单独的某个中断的屏蔽。
            在刘亚宁学长的os\_lab中，启动过程中是通过MASK位进行屏蔽，
            保证不会被时钟中断所打断。

            此次实验中在硬件上没有提供对MASK位的支持，因此选择在操作系统上进行修改。
            CP0的Compare寄存器初始化为0xFFFFFFFF，保证初始化结束之前一定不会触发时钟中断。
            初始化完成后增加一次对clock\_intr函数的调用，
            将Compare寄存器重填为设定的数字，之后即可触发时钟中断。

            标准MIPS时钟中断还应该在硬件上实现“读Count写入Compare”功能，
            此问题已经在os\_lab中通过软件方式解决，不需要另作处理。

        \subsubsection{串口}
            从lab3开始，由于刘亚宁学长的代码支持了在实验板与qemu两个平台上的运行，
            两平台的串口地址不同。因此，在编译操作系统前需要先调用to\_thin脚本，
            将操作系统转换为实验板上的版本。

            使用贾开学长推荐的开源串口代码，实现了稳定的传输。

            串口实现为一个数据位加一个状态位。状态位第0位为是否可写，第1位为是否可读。
            读写串口前都会先检查是否可读可写，之后才进行真正的读写操作。
            此次实验中，串口的写标记为始终可写，在串口写的过程中阻塞CPU，
            写过程结束之后CPU才会继续执行后续的指令。
            串口的读标记直接使用开源串口工具的读标记，并输出至CPU顶层模块，用来触发串口中断。

            串口的读写使用的是LW和SW指令，对32bit进行操作，但实际上之后低8位是有效的。

        \subsubsection{系统调用}
            系统调用syscall指令会触发一个异常，异常处理结束后应该跳转到下一条指令继续执行。
            其中EPC加4的操作是由操作系统实现的，不需要提供硬件支持。
            因此，对于所有中断和异常的处理，其EPC均为当前指令的地址。

        \subsubsection{异常处理向量}
            刘亚宁学长的异常处理向量只有唯一的一个入口0x80000180，
            在初始化阶段直接写入EBASE寄存器之后就不需要再进行修改了。
            异常处理的初始化完全由操作系统完成，
            在0x80000180存入一条jump指令，
            跳转值alltraps函数，硬件上不需要任何的特殊处理。

        \subsubsection{异常定义}
            操作系统对某些异常并没有进行处理，
            而是直接停止执行后进入debug\_monitor模式，
            这些异常包括AdEL、AdES、TLB\_Modify。

            在lab5的check\_swap部分中曾出现过TLB\_Modify的异常，
            操作系统生成的两个物理页的的D标记有问题，原因不明。
            最后在硬件上直接取消了异常，操作系统即可正常运行通过check\_swap，
            并且之后的代码也能够正常运行，因此直到最后的lab8仍然采用的是这种方式。

            AdEL与AdES两种异常，指导文档中给出的定义是地址不对齐，
            但实际上内存的跨界访问（用户态访问内核态）也是通过这两个异常表示的。

        \subsubsection{Status寄存器}
            Status寄存器在此次实验中有4个相关位需要设置：
            \begin{enumerate}
            \item
                EL：
                通过软件进行设置，与中断屏蔽相关。
                硬件上只进行检测，判断是否可以触发中断，
                该位功能的详细说明请参考《See MIPS Run》
            \item
                EXL:
                硬件进行设置，进入异常处理时设置为1，退出异常处理时设置为0。
                硬件上进行检测，判断是否可以触发中断。
            \item
                KSU：
                通过软件进行设置，区分用户态和内核态。
                硬件上可以不作处理，
                但是如果需要检测用户态访问内核态地址的错误，可以使用这一位进行判断
            \item
                MASK：
                通过软件进行设置，屏蔽某一种中断。
                硬件上可以不作处理，
                但是如果需要单独屏蔽某一种中断，可以使用这一位进行判断。
            \end{enumerate}


    \subsection{其他}
        \subsubsection{操作系统组成}
            此次实验中操作系统
            bootloader部分使用贾开学长的代码
            （与Flash访问方式有关，见第二点说明），
            其余均在刘亚宁学长os\_lab基础上进行修改，
            具体修改内容之后有详细叙述。

        \subsubsection{Flash访问}
            因为Flash数据线只有16条，
            所以实际上Flash连续的4个byte中只有2个为有效数据，
            因此产生了两种Flash访问方式如下：

            一种方式为每次访问Flash的4个byte，
            得到32位数据中只有低16位有效。
            之后在软件层进行控制，连续访问两次，
            将结果移位拼接得到32位有效数据。
            另一种方式为每次访问Flash在硬件上访问8个byte，
            硬件上将两次得到的数据进行拼接，
            对操作系统层提供与RAM访问相同的接口。

            此次实验中我们使用第一种方式。
            因此在bootloader中使用贾开学长的代码，
            其中包含了将访存结果移位拼接的实现。
            除bootloader之外的操作系统使用刘亚宁学长的代码，
            这些代码需要第二种Flash访问方式进行支持。

            lab1到lab7不需要进行任何修改，
            因为所有Flash访问操作均是在bootloader部分完成。
            在lab8中由于涉及到文件系统sfs.img的加载，
            需要修改lab8/kern/fs/devs/dev\_disk0.c
            中的disk0\_read\_blks\_nolock函数，
            将Flash起始地址与DISK0\_BLKSIZE均乘2，
            之后通特别外实现的memcpy\_flash将sfs.img加载到内存中

        \subsubsection{初始化}
            bootloader运行前需要对硬件做一次初始化，
            主要是各种寄存器的初始值设置。
            在此次实验中利用实验板的rst开关进行。

            CP0寄存器Compare寄存器全部设置为1，
            保证操作系统初始化完成前不会触发时钟中断。
            EBASE寄存器设置为0x80000180，
            为异常处理向量起始地址。
            其余CP0寄存器均设置为0。

            访存地址设置为0x90000000，
            为bootloader的起始地址。
            通用寄存器全部设置为0。
            各个模块的辅助信号按照需求进行初始化。

        \subsubsection{ROM}
            操作系统需要一块ROM保存
            bootloader中的指令，需要保证断电不失。
            Xilinx提供的IPcore中可以实现片内的ROM，但是使用方法比较复杂。

            另一种实现方式，也是本次实验中使用的方式，
            是直接用VHDL语言生成一个std\_logic\_vector
            的常量数组，保存每一条指令。
            之后直接通过下标进行访问即可。
            
