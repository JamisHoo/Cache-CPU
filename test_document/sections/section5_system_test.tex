\section{系统测试}
    项目测试进入第四个阶段。%
    在该阶段，直接采用ucore作为我们的测试程序。%
    从lab1到lab8逐渐增加功能，%
    最终运行一个完整的操作系统。

    该阶段在软件硬件接口方面可能出现问题，%
    原有操作系统与硬件之间的接口可能需要修改。%
    此外，异常处理、系统调用、中断等情况，%
    在前期指令片段测试中比较难以模拟，%
    有可能在此阶段出现问题。

    \subsection{测试内容}
        采用ucore的lab1到lab8作为测试内容。
        各个lab的说明详见表\ref{os_lab}
        \begin{table}[!hbp]
            \centering
            \caption{lab1至lab8简要说明}
            \label{os_lab}
            \begin{tabularx}{\textwidth}{|l|X|}
            \hline
            编号 & 说明 \\
            \hline
            lab1 &　通过bootloader启动操作系统，
                    初始化异常处理向量，初始化时钟中断。
                    运行正常则可以向串口周期性的输出数字。 \\
            \hline
            lab2 & 在lab1的基础上，完成物理内存的初始化。
                    操作系统内部通过assert进行检查，
                    如果出现问题会报assert failed错误
                    并进入debug monitor    \\
            \hline
            lab3 & 在lab2的基础上，完成虚拟内存的管理，
                    包括对TLB表项的初始化、重填等操作。 \\
            \hline
            lab4 & 创建内核级线程。
                    该lab正常运行结束后也会进入debug monitor模式，
                    只要根据终端的输出，观察到通过了一系列check即可。 \\
            \hline
            lab5 & 创建用户级线程。
                    正常运行结束的表现同lab4。 \\
            \hline
            lab6 & 实现线程间的调度。    \\
            \hline
            lab7 & 实现线程的同步互斥。   \\
            \hline
            lab8 & 实现文件系统，能够进入用户态，通过串口输入指令并执行。  \\
            \hline
            \end{tabularx}
            \end{table}

    \subsection{测试方法}
        在系统测试阶段，使用本组开发的调试工具进行测试。%
        通过debug工具设置断点，%
        运行至断点后通过串口输出所有可能需要查看的信号。%
        在PC端查看信号进行调试。

        另一种测试方法为修改操作系统。%
        在操作系统中插入输出语句，%
        重新编译操作系统后烧入Flash执行。%
        通过查看启动过程中的输出信息，%
        定位出现问题的位置。%
        
        该阶段测试需要用到两个串口。

    \subsection{问题与解决}
        该阶段发现了比较多的问题，%
        在此逐个罗列问题的现象、原因与解决方案。%

        \subsubsection{操作系统启动}
            问题现象：原先设定为按下rst键后执行硬件初始化，%
            再按下clk之后开始运行。%
            但是上述过程总是需要反复多次，%
            才能启动操作系统。

            问题原因：硬件初始化问题。%
            VHDL语言中在信号定义时给定的初始值是不稳定的。%
            需要根据rst信号进行一次赋值，%
            才能完成正常初始化。

            解决方案：在每一个独立模块中，%
            都添加rst信号，与实验板的rst键相连。%
            对于每一个用到的信号，%
            都在rst为0时赋值为应有的初始值。

        \subsubsection{代码段覆盖}
            问题现象：在lab1测试过程中，随着程序的不断执行，%
            一部分指令被数据覆盖，导致操作系统崩溃。

            问题原因：编译器版本不同，导致代码段组装顺序不同。%
            初始化内核栈指针时，将其设置为了代码中间的一个函数，%
            导致运行过程中代码段被覆盖。

            解决方案：根据不同的编译器版本，可能需要修改kern\_boot函数，设置栈指针为代码段顶端的kern\_init函数。

            此次实验中采用的编译工具为%
            mips-linux-gnu工具链，%
            版本为(Sourcery CodeBench Lite 2014.05-27)%
            2.24.51.20140217。%
            在该版本下只有lab1出现了这个问题。

        \subsubsection{时钟中断}
            问题现象：在lab1测试过程中，最后无法触发时钟中断。%
            不能周期性地输出数字。

            问题原因：在os\_lab中，%
            启动过程中是通过MASK位进行中断屏蔽，%
            保证不会被时钟中断所打断。%
            此次试验在硬件上没有提供对MASK位的支持，%
            而是初始化compare寄存器全为1，%
            compare过大导致不能触发时钟中断。

            解决方案：在操作系统上进行修改。%
            CP0的Compare寄存器初始化为0xFFFFFFFF，保证初始化结束之前一定不会触发时钟中断。%
            初始化完成后增加一次对clock\_intr函数的调用，%
            将Compare寄存器重填为设定的数字，之后即可触发时钟中断。

        \subsubsection{CP0寄存器编号}
            问题现象：lab3不能正常触发TLB异常。

            问题原因：CP0寄存器编号错误。%
            在原实验指导文档中的CP0寄存器编号有误，%
            导致异常相关的信息被写入了错误的寄存器，%
            异常触发失败。%

            解决方案：参考《See MIPS Run》，%
            其中有标准MIPS32的CP0寄存器编号，%
            按照书中的编号实现。

        \subsubsection{串口地址}
            问题现象：在lab3中，%
            串口不能够正常输出启动过程的信息。%
            但在lab1和lab2中能够正常工作。

            问题原因：从lab3开始，%
            代码支持了在实验板与qemu两个平台上的运行，%
            两平台的串口地址不同。

            解决方案：在编译操作系统前需要先调用to\_thin脚本，%
            将操作系统转换为实验板上的版本。

        \subsubsection{系统调用返回}
            问题现象：在lab5中，%
            syscall系统调用创建用户级线程，%
            但是syscall异常返回后程序陷入死循环。

            问题原因：lab5中的syscall异常返回后，%
            下一条指令就是用户态程序的第一条指令，%
            在取指阶段会立刻触发tlbmiss异常。%
            原有实现中，eret\_enable信号在下一条指令的解码阶段消除，%
            但是这种情况下，根本没有进入解码阶段，%
            反复从eret的返回地址处取指令，%
            导致程序陷入死循环。

            解决方案：将eret\_enable信号在取指阶段消除，%
            用户态程序即可正常调用。
            
        \subsubsection{Flash访问}
            问题现象：lab8加载文件系统是SFS\_MAGIC与预设值不等。

            问题原因：Flash数据线只有16条，%
            所以实际上Flash连续的4个byte中只有2个为有效数据，%
            因此产生了两种Flash访问方式如下：

            一种方式为每次访问Flash的4个byte，%
            得到32位数据中只有低16位有效。%
            之后在软件层进行控制，连续访问两次，%
            将结果移位拼接得到32位有效数据。%
            另一种方式为每次访问Flash在硬件上访问8个byte，%
            硬件上将两次得到的数据进行拼接，%
            对操作系统层提供与RAM访问相同的接口。

            此次实验中在硬件上实现方式为第一种方式，%
            但是在操作系统上要求为第二种方式。

            解决方案：lab1到lab7不需要进行任何修改，%
            因为所有Flash访问操作均是在bootloader部分完成。%
            在lab8中由于涉及到文件系统sfs.img的加载，%
            需要修改lab8/kern/fs/devs/dev\_disk0.c%
            中的disk0\_read\_blks\_nolock函数，%
            将Flash起始地址与DISK0\_BLKSIZE均乘2，%
            之后通特别外实现的memcpy\_flash将sfs.img加载到内存中。

        \subsubsection{地址信号}
            问题现象：lab8多个线程切换时内存管理错误。

            问题原因：由于实现方式的原因，%
            取指令和访存均需要两个上升沿才能够完成。%
            在取指令模块和MMU模块，%
            第二个访存上升沿时又对地址信号进行了一次赋值，%
            而这时的地址信号可能已经发生了改变，%
            导致内存管理出现异常。

            解决方案：在取指令模块和MMU模块增加对地址的锁存，%
            且只有在访存或取指令的第一个上升沿才允许对地址进行重新赋值。

        